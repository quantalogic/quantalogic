Before generating the code, follow these steps:

1. **Review the History**: Examine the <History> section below to understand previous thoughts, actions, and results.
2. **Identify Available Variables**: Check the 'Currently available variables' list and 'Available variables' in the history. These are stored in the `context_vars` dictionary and can be accessed using `context_vars.get('variable_name', default_value)`.
3. **Understand Variable Types**: Variables in `context_vars` are objects returned by tools, not just their string representations. Refer to tool documentation (e.g., `create_project_plan` returns `PlanResult` with `task_id`, `task_description`, `subtasks`) to access attributes directly (e.g., `plan.task_id`) rather than parsing strings.
4. **Use Previous Results**: Incorporate relevant variables from prior steps to avoid redundant calculations and ensure continuity. For example, if `step1_plan` is a `PlanResult`, retrieve it with `plan = context_vars.get('step1_plan')` and use `plan.task_id`.
5. **Use Conversation History**: Access `context_vars["conversation_history"]` to retrieve a list of previous messages (e.g., [{"role": "user", "content": "Hi"}, {"role": "assistant", "content": "Hello"}]). Pass this to `default.agent_tool` using the `history` parameter when context is needed.
6. **Plan Your Approach**: Based on the history and variables, determine the next logical step toward solving the task.
7. Never use sorted and lambda functions

Currently available variables from previous steps: {{ available_vars | join(', ') }}

Solve the following task: 

<Task>
{{ task }}
</Task>

This is step {{ current_step }} out of {{ max_iterations }} allowed steps.

Previous steps:

<History>
{{ history_str }}
</History>

Task:

Generate a Python program with an async main() function that uses the available tools to take the next step toward solving the task.

Essential Requirements:

- You support only a subset of Python 3.10+ syntax: no lambda support, only named parameters in functions calls, no sorted support, use simple constructions
- **Always check the 'Available variables' from the history** before proceeding. These are listed in the <History> section and stored in the `context_vars` dictionary as objects. Access them using `context_vars.get("variable_name", default_value)` to retrieve results from previous steps.
- **Handle Variable Types Correctly**: Variables in `context_vars` are the actual objects returned by tools (e.g., `PlanResult` from `create_project_plan`). Use attribute access (e.g., `plan.task_id`) instead of string methods like `split()` unless the variable is explicitly a string. Check tool documentation for return types.
- **Build upon previous steps** by using these variables when they are relevant. This avoids redundant work and ensures continuity. For example, if a previous step stored a `PlanResult` as `step1_plan`, retrieve it with `plan = context_vars.get('step1_plan')` and use `plan.task_id`.
- **Conversation History**: Use `context_vars["conversation_history"]` when calling `default.agent_tool` by passing it as `history=context_vars.get("conversation_history", [])`. This provides the agent with prior conversation context.
- When defining new variables, **prefix them with 'step{{ current_step }}_'** to ensure uniqueness (e.g., `step{{ current_step }}_result`).
- Return `"Task completed: [final answer]"` if the task is fully solved in this step.
- Otherwise, return intermediate results as a string to be stored for future steps.
- Handle potential errors in tool arguments gracefully, using try/except blocks if needed.
- Use proper async/await syntax for all asynchronous operations.
- Be careful when responding to the user, ensure to use nicely presented results.

Variable Naming Convention:
- Prefix all new variables with 'step{{ current_step }}_' (e.g., `step{{ current_step }}_result = ...`).
- This ensures variables are unique across steps and traceable to their origin.

Example with conversation history:
Task: "Respond based on our previous chat"
History: (assume context_vars["conversation_history"] exists from prior steps)

Code:
import asyncio

async def main():
    step{{ current_step }}_history: list = context_vars.get("conversation_history", [])
    step{{ current_step }}_system_prompt: str = "You are a helpful assistant continuing a conversation."
    step{{ current_step }}_response: str = await default.agent_tool(
        system_prompt=step{{ current_step }}_system_prompt,
        prompt="Continue our previous conversation.",
        temperature=0.7,
        history=step{{ current_step }}_history
    )
    return f"Task completed: {step{{ current_step }}_response}"

Error Reflection:
- If there were errors in previous steps, review the error messages in the <History> section and adjust your code to avoid similar issues.
- For example, if a variable was missing, check `context_vars` with a default value.
- If a tool call failed, verify the arguments and ensure they match the tool's requirements.
- If an error like "'PlanResult' object has no attribute 'split'" occurred, it means you tried to treat an object as a string. Use attribute access instead (e.g., `.task_id`).

The program must:

1. Use only the provided async tools
2. Follow a subset of Python 3.10+ syntax, doesn't allow unsafe operations such as eval() or exec()
3. Include type annotations for variables, give very explicit names to variables
4. Output progress information